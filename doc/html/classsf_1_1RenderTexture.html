<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Micro Machine: sf::RenderTexture Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Micro Machine
   &#160;<span id="projectnumber">1</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacesf.html">sf</a></li><li class="navelem"><a class="el" href="classsf_1_1RenderTexture.html">RenderTexture</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="classsf_1_1RenderTexture-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">sf::RenderTexture Class Reference<div class="ingroups"><a class="el" href="group__graphics.html">Graphics module</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Target for off-screen 2D rendering into a texture.  
 <a href="classsf_1_1RenderTexture.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="RenderTexture_8hpp_source.html">RenderTexture.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for sf::RenderTexture:</div>
<div class="dyncontent">
<div class="center"><img src="classsf_1_1RenderTexture__inherit__graph.png" border="0" usemap="#asf_1_1RenderTexture_inherit__map" alt="Inheritance graph"/></div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for sf::RenderTexture:</div>
<div class="dyncontent">
<div class="center"><img src="classsf_1_1RenderTexture__coll__graph.png" border="0" usemap="#asf_1_1RenderTexture_coll__map" alt="Collaboration graph"/></div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a19ee6e5b4c40ad251803389b3953a9c6"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsf_1_1RenderTexture.html#a19ee6e5b4c40ad251803389b3953a9c6">RenderTexture</a> ()</td></tr>
<tr class="memdesc:a19ee6e5b4c40ad251803389b3953a9c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor.  <a href="classsf_1_1RenderTexture.html#a19ee6e5b4c40ad251803389b3953a9c6">More...</a><br /></td></tr>
<tr class="separator:a19ee6e5b4c40ad251803389b3953a9c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a014c4d5e8a1daf93c9948f4b4655f625"><td class="memItemLeft" align="right" valign="top"><a id="a014c4d5e8a1daf93c9948f4b4655f625"></a>
virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsf_1_1RenderTexture.html#a014c4d5e8a1daf93c9948f4b4655f625">~RenderTexture</a> ()</td></tr>
<tr class="memdesc:a014c4d5e8a1daf93c9948f4b4655f625"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor. <br /></td></tr>
<tr class="separator:a014c4d5e8a1daf93c9948f4b4655f625"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e945c4ce7703591c7f240b169744603"><td class="memItemLeft" align="right" valign="top">SFML_DEPRECATED bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsf_1_1RenderTexture.html#a0e945c4ce7703591c7f240b169744603">create</a> (unsigned int width, unsigned int height, bool depthBuffer)</td></tr>
<tr class="memdesc:a0e945c4ce7703591c7f240b169744603"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create the render-texture.  <a href="classsf_1_1RenderTexture.html#a0e945c4ce7703591c7f240b169744603">More...</a><br /></td></tr>
<tr class="separator:a0e945c4ce7703591c7f240b169744603"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49b7b723a80f89bc409a942364351dc3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsf_1_1RenderTexture.html#a49b7b723a80f89bc409a942364351dc3">create</a> (unsigned int width, unsigned int height, const <a class="el" href="structsf_1_1ContextSettings.html">ContextSettings</a> &amp;settings=<a class="el" href="structsf_1_1ContextSettings.html">ContextSettings</a>())</td></tr>
<tr class="memdesc:a49b7b723a80f89bc409a942364351dc3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create the render-texture.  <a href="classsf_1_1RenderTexture.html#a49b7b723a80f89bc409a942364351dc3">More...</a><br /></td></tr>
<tr class="separator:a49b7b723a80f89bc409a942364351dc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af08991e63c6020865dd07b20e27305b6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsf_1_1RenderTexture.html#af08991e63c6020865dd07b20e27305b6">setSmooth</a> (bool smooth)</td></tr>
<tr class="memdesc:af08991e63c6020865dd07b20e27305b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable or disable texture smoothing.  <a href="classsf_1_1RenderTexture.html#af08991e63c6020865dd07b20e27305b6">More...</a><br /></td></tr>
<tr class="separator:af08991e63c6020865dd07b20e27305b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b43c007ab6643accc5dae84b5bc8f61"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsf_1_1RenderTexture.html#a5b43c007ab6643accc5dae84b5bc8f61">isSmooth</a> () const</td></tr>
<tr class="memdesc:a5b43c007ab6643accc5dae84b5bc8f61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tell whether the smooth filtering is enabled or not.  <a href="classsf_1_1RenderTexture.html#a5b43c007ab6643accc5dae84b5bc8f61">More...</a><br /></td></tr>
<tr class="separator:a5b43c007ab6643accc5dae84b5bc8f61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8f97b33512bf7d5b6be3da6f65f7365"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsf_1_1RenderTexture.html#af8f97b33512bf7d5b6be3da6f65f7365">setRepeated</a> (bool repeated)</td></tr>
<tr class="memdesc:af8f97b33512bf7d5b6be3da6f65f7365"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable or disable texture repeating.  <a href="classsf_1_1RenderTexture.html#af8f97b33512bf7d5b6be3da6f65f7365">More...</a><br /></td></tr>
<tr class="separator:af8f97b33512bf7d5b6be3da6f65f7365"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81c5a453a21c7e78299b062b97dc8c87"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsf_1_1RenderTexture.html#a81c5a453a21c7e78299b062b97dc8c87">isRepeated</a> () const</td></tr>
<tr class="memdesc:a81c5a453a21c7e78299b062b97dc8c87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tell whether the texture is repeated or not.  <a href="classsf_1_1RenderTexture.html#a81c5a453a21c7e78299b062b97dc8c87">More...</a><br /></td></tr>
<tr class="separator:a81c5a453a21c7e78299b062b97dc8c87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ca34c8b7e00793c1d3ef4f9a834f8cc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsf_1_1RenderTexture.html#a8ca34c8b7e00793c1d3ef4f9a834f8cc">generateMipmap</a> ()</td></tr>
<tr class="memdesc:a8ca34c8b7e00793c1d3ef4f9a834f8cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a mipmap using the current texture data.  <a href="classsf_1_1RenderTexture.html#a8ca34c8b7e00793c1d3ef4f9a834f8cc">More...</a><br /></td></tr>
<tr class="separator:a8ca34c8b7e00793c1d3ef4f9a834f8cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5da95ecdbce615a80bb78399012508cf"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsf_1_1RenderTexture.html#a5da95ecdbce615a80bb78399012508cf">setActive</a> (bool active=true)</td></tr>
<tr class="memdesc:a5da95ecdbce615a80bb78399012508cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Activate or deactivate the render-texture for rendering.  <a href="classsf_1_1RenderTexture.html#a5da95ecdbce615a80bb78399012508cf">More...</a><br /></td></tr>
<tr class="separator:a5da95ecdbce615a80bb78399012508cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af92886d5faef3916caff9fa9ab32c555"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsf_1_1RenderTexture.html#af92886d5faef3916caff9fa9ab32c555">display</a> ()</td></tr>
<tr class="memdesc:af92886d5faef3916caff9fa9ab32c555"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update the contents of the target texture.  <a href="classsf_1_1RenderTexture.html#af92886d5faef3916caff9fa9ab32c555">More...</a><br /></td></tr>
<tr class="separator:af92886d5faef3916caff9fa9ab32c555"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09a4e928dafb7fcf397b8fd3d0f98ee8"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classsf_1_1Vector2.html">Vector2u</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsf_1_1RenderTexture.html#a09a4e928dafb7fcf397b8fd3d0f98ee8">getSize</a> () const</td></tr>
<tr class="memdesc:a09a4e928dafb7fcf397b8fd3d0f98ee8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the size of the rendering region of the texture.  <a href="classsf_1_1RenderTexture.html#a09a4e928dafb7fcf397b8fd3d0f98ee8">More...</a><br /></td></tr>
<tr class="separator:a09a4e928dafb7fcf397b8fd3d0f98ee8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b0c1876cfb411d7db737d85b38c062c"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsf_1_1RenderTexture.html#a2b0c1876cfb411d7db737d85b38c062c">isSrgb</a> () const</td></tr>
<tr class="memdesc:a2b0c1876cfb411d7db737d85b38c062c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tell if the render-texture will use sRGB encoding when drawing on it.  <a href="classsf_1_1RenderTexture.html#a2b0c1876cfb411d7db737d85b38c062c">More...</a><br /></td></tr>
<tr class="separator:a2b0c1876cfb411d7db737d85b38c062c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61a6eba45d5c9e5c913aebeccb7b7eda"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classsf_1_1Texture.html">Texture</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsf_1_1RenderTexture.html#a61a6eba45d5c9e5c913aebeccb7b7eda">getTexture</a> () const</td></tr>
<tr class="memdesc:a61a6eba45d5c9e5c913aebeccb7b7eda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a read-only reference to the target texture.  <a href="classsf_1_1RenderTexture.html#a61a6eba45d5c9e5c913aebeccb7b7eda">More...</a><br /></td></tr>
<tr class="separator:a61a6eba45d5c9e5c913aebeccb7b7eda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classsf_1_1RenderTarget"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classsf_1_1RenderTarget')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classsf_1_1RenderTarget.html">sf::RenderTarget</a></td></tr>
<tr class="memitem:a45414a2f09b257db7e7b37861d70c5a0 inherit pub_methods_classsf_1_1RenderTarget"><td class="memItemLeft" align="right" valign="top"><a id="a45414a2f09b257db7e7b37861d70c5a0"></a>
virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsf_1_1RenderTarget.html#a45414a2f09b257db7e7b37861d70c5a0">~RenderTarget</a> ()</td></tr>
<tr class="memdesc:a45414a2f09b257db7e7b37861d70c5a0 inherit pub_methods_classsf_1_1RenderTarget"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor. <br /></td></tr>
<tr class="separator:a45414a2f09b257db7e7b37861d70c5a0 inherit pub_methods_classsf_1_1RenderTarget"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bb6f0ba348f2b1e2f46114aeaf60f26 inherit pub_methods_classsf_1_1RenderTarget"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsf_1_1RenderTarget.html#a6bb6f0ba348f2b1e2f46114aeaf60f26">clear</a> (const <a class="el" href="classsf_1_1Color.html">Color</a> &amp;color=<a class="el" href="classsf_1_1Color.html">Color</a>(0, 0, 0, 255))</td></tr>
<tr class="memdesc:a6bb6f0ba348f2b1e2f46114aeaf60f26 inherit pub_methods_classsf_1_1RenderTarget"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear the entire target with a single color.  <a href="classsf_1_1RenderTarget.html#a6bb6f0ba348f2b1e2f46114aeaf60f26">More...</a><br /></td></tr>
<tr class="separator:a6bb6f0ba348f2b1e2f46114aeaf60f26 inherit pub_methods_classsf_1_1RenderTarget"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a063db6dd0a14913504af30e50cb6d946 inherit pub_methods_classsf_1_1RenderTarget"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsf_1_1RenderTarget.html#a063db6dd0a14913504af30e50cb6d946">setView</a> (const <a class="el" href="classsf_1_1View.html">View</a> &amp;view)</td></tr>
<tr class="memdesc:a063db6dd0a14913504af30e50cb6d946 inherit pub_methods_classsf_1_1RenderTarget"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change the current active view.  <a href="classsf_1_1RenderTarget.html#a063db6dd0a14913504af30e50cb6d946">More...</a><br /></td></tr>
<tr class="separator:a063db6dd0a14913504af30e50cb6d946 inherit pub_methods_classsf_1_1RenderTarget"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbf8dc5a1f4abbe15a3fbb915844c7ea inherit pub_methods_classsf_1_1RenderTarget"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classsf_1_1View.html">View</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsf_1_1RenderTarget.html#adbf8dc5a1f4abbe15a3fbb915844c7ea">getView</a> () const</td></tr>
<tr class="memdesc:adbf8dc5a1f4abbe15a3fbb915844c7ea inherit pub_methods_classsf_1_1RenderTarget"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the view currently in use in the render target.  <a href="classsf_1_1RenderTarget.html#adbf8dc5a1f4abbe15a3fbb915844c7ea">More...</a><br /></td></tr>
<tr class="separator:adbf8dc5a1f4abbe15a3fbb915844c7ea inherit pub_methods_classsf_1_1RenderTarget"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7741129e3ef7ab4f0a40024fca13480c inherit pub_methods_classsf_1_1RenderTarget"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classsf_1_1View.html">View</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsf_1_1RenderTarget.html#a7741129e3ef7ab4f0a40024fca13480c">getDefaultView</a> () const</td></tr>
<tr class="memdesc:a7741129e3ef7ab4f0a40024fca13480c inherit pub_methods_classsf_1_1RenderTarget"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the default view of the render target.  <a href="classsf_1_1RenderTarget.html#a7741129e3ef7ab4f0a40024fca13480c">More...</a><br /></td></tr>
<tr class="separator:a7741129e3ef7ab4f0a40024fca13480c inherit pub_methods_classsf_1_1RenderTarget"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a865d462915dc2a1fae2ebfb3300382ac inherit pub_methods_classsf_1_1RenderTarget"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsf_1_1Rect.html">IntRect</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsf_1_1RenderTarget.html#a865d462915dc2a1fae2ebfb3300382ac">getViewport</a> (const <a class="el" href="classsf_1_1View.html">View</a> &amp;view) const</td></tr>
<tr class="memdesc:a865d462915dc2a1fae2ebfb3300382ac inherit pub_methods_classsf_1_1RenderTarget"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the viewport of a view, applied to this render target.  <a href="classsf_1_1RenderTarget.html#a865d462915dc2a1fae2ebfb3300382ac">More...</a><br /></td></tr>
<tr class="separator:a865d462915dc2a1fae2ebfb3300382ac inherit pub_methods_classsf_1_1RenderTarget"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0103ebebafa43a97e6e6414f8560d5e3 inherit pub_methods_classsf_1_1RenderTarget"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsf_1_1Vector2.html">Vector2f</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsf_1_1RenderTarget.html#a0103ebebafa43a97e6e6414f8560d5e3">mapPixelToCoords</a> (const <a class="el" href="classsf_1_1Vector2.html">Vector2i</a> &amp;point) const</td></tr>
<tr class="memdesc:a0103ebebafa43a97e6e6414f8560d5e3 inherit pub_methods_classsf_1_1RenderTarget"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a point from target coordinates to world coordinates, using the current view.  <a href="classsf_1_1RenderTarget.html#a0103ebebafa43a97e6e6414f8560d5e3">More...</a><br /></td></tr>
<tr class="separator:a0103ebebafa43a97e6e6414f8560d5e3 inherit pub_methods_classsf_1_1RenderTarget"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d3e9d7c4a1f5ea7e52b06f53e3011f9 inherit pub_methods_classsf_1_1RenderTarget"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsf_1_1Vector2.html">Vector2f</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsf_1_1RenderTarget.html#a2d3e9d7c4a1f5ea7e52b06f53e3011f9">mapPixelToCoords</a> (const <a class="el" href="classsf_1_1Vector2.html">Vector2i</a> &amp;point, const <a class="el" href="classsf_1_1View.html">View</a> &amp;view) const</td></tr>
<tr class="memdesc:a2d3e9d7c4a1f5ea7e52b06f53e3011f9 inherit pub_methods_classsf_1_1RenderTarget"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a point from target coordinates to world coordinates.  <a href="classsf_1_1RenderTarget.html#a2d3e9d7c4a1f5ea7e52b06f53e3011f9">More...</a><br /></td></tr>
<tr class="separator:a2d3e9d7c4a1f5ea7e52b06f53e3011f9 inherit pub_methods_classsf_1_1RenderTarget"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad92a9f0283aa5f3f67e473c1105b68cf inherit pub_methods_classsf_1_1RenderTarget"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsf_1_1Vector2.html">Vector2i</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsf_1_1RenderTarget.html#ad92a9f0283aa5f3f67e473c1105b68cf">mapCoordsToPixel</a> (const <a class="el" href="classsf_1_1Vector2.html">Vector2f</a> &amp;point) const</td></tr>
<tr class="memdesc:ad92a9f0283aa5f3f67e473c1105b68cf inherit pub_methods_classsf_1_1RenderTarget"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a point from world coordinates to target coordinates, using the current view.  <a href="classsf_1_1RenderTarget.html#ad92a9f0283aa5f3f67e473c1105b68cf">More...</a><br /></td></tr>
<tr class="separator:ad92a9f0283aa5f3f67e473c1105b68cf inherit pub_methods_classsf_1_1RenderTarget"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a848eee44b72ac3f16fa9182df26e83bc inherit pub_methods_classsf_1_1RenderTarget"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsf_1_1Vector2.html">Vector2i</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsf_1_1RenderTarget.html#a848eee44b72ac3f16fa9182df26e83bc">mapCoordsToPixel</a> (const <a class="el" href="classsf_1_1Vector2.html">Vector2f</a> &amp;point, const <a class="el" href="classsf_1_1View.html">View</a> &amp;view) const</td></tr>
<tr class="memdesc:a848eee44b72ac3f16fa9182df26e83bc inherit pub_methods_classsf_1_1RenderTarget"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a point from world coordinates to target coordinates.  <a href="classsf_1_1RenderTarget.html#a848eee44b72ac3f16fa9182df26e83bc">More...</a><br /></td></tr>
<tr class="separator:a848eee44b72ac3f16fa9182df26e83bc inherit pub_methods_classsf_1_1RenderTarget"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12417a3bcc245c41d957b29583556f39 inherit pub_methods_classsf_1_1RenderTarget"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsf_1_1RenderTarget.html#a12417a3bcc245c41d957b29583556f39">draw</a> (const <a class="el" href="classsf_1_1Drawable.html">Drawable</a> &amp;drawable, const <a class="el" href="classsf_1_1RenderStates.html">RenderStates</a> &amp;states=<a class="el" href="classsf_1_1RenderStates.html#ad29672df29f19ce50c3021d95f2bb062">RenderStates::Default</a>)</td></tr>
<tr class="memdesc:a12417a3bcc245c41d957b29583556f39 inherit pub_methods_classsf_1_1RenderTarget"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draw a drawable object to the render target.  <a href="classsf_1_1RenderTarget.html#a12417a3bcc245c41d957b29583556f39">More...</a><br /></td></tr>
<tr class="separator:a12417a3bcc245c41d957b29583556f39 inherit pub_methods_classsf_1_1RenderTarget"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a976bc94057799eb9f8a18ac5fdfd9b73 inherit pub_methods_classsf_1_1RenderTarget"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsf_1_1RenderTarget.html#a976bc94057799eb9f8a18ac5fdfd9b73">draw</a> (const <a class="el" href="classsf_1_1Vertex.html">Vertex</a> *vertices, std::size_t vertexCount, <a class="el" href="group__graphics.html#ga5ee56ac1339984909610713096283b1b">PrimitiveType</a> type, const <a class="el" href="classsf_1_1RenderStates.html">RenderStates</a> &amp;states=<a class="el" href="classsf_1_1RenderStates.html#ad29672df29f19ce50c3021d95f2bb062">RenderStates::Default</a>)</td></tr>
<tr class="memdesc:a976bc94057799eb9f8a18ac5fdfd9b73 inherit pub_methods_classsf_1_1RenderTarget"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draw primitives defined by an array of vertices.  <a href="classsf_1_1RenderTarget.html#a976bc94057799eb9f8a18ac5fdfd9b73">More...</a><br /></td></tr>
<tr class="separator:a976bc94057799eb9f8a18ac5fdfd9b73 inherit pub_methods_classsf_1_1RenderTarget"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3dc4d06f081d36ca1e8f1a1298d49abc inherit pub_methods_classsf_1_1RenderTarget"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsf_1_1RenderTarget.html#a3dc4d06f081d36ca1e8f1a1298d49abc">draw</a> (const <a class="el" href="classsf_1_1VertexBuffer.html">VertexBuffer</a> &amp;vertexBuffer, const <a class="el" href="classsf_1_1RenderStates.html">RenderStates</a> &amp;states=<a class="el" href="classsf_1_1RenderStates.html#ad29672df29f19ce50c3021d95f2bb062">RenderStates::Default</a>)</td></tr>
<tr class="memdesc:a3dc4d06f081d36ca1e8f1a1298d49abc inherit pub_methods_classsf_1_1RenderTarget"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draw primitives defined by a vertex buffer.  <a href="classsf_1_1RenderTarget.html#a3dc4d06f081d36ca1e8f1a1298d49abc">More...</a><br /></td></tr>
<tr class="separator:a3dc4d06f081d36ca1e8f1a1298d49abc inherit pub_methods_classsf_1_1RenderTarget"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07cb25d4557a30146b24b25b242310ea inherit pub_methods_classsf_1_1RenderTarget"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsf_1_1RenderTarget.html#a07cb25d4557a30146b24b25b242310ea">draw</a> (const <a class="el" href="classsf_1_1VertexBuffer.html">VertexBuffer</a> &amp;vertexBuffer, std::size_t firstVertex, std::size_t vertexCount, const <a class="el" href="classsf_1_1RenderStates.html">RenderStates</a> &amp;states=<a class="el" href="classsf_1_1RenderStates.html#ad29672df29f19ce50c3021d95f2bb062">RenderStates::Default</a>)</td></tr>
<tr class="memdesc:a07cb25d4557a30146b24b25b242310ea inherit pub_methods_classsf_1_1RenderTarget"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draw primitives defined by a vertex buffer.  <a href="classsf_1_1RenderTarget.html#a07cb25d4557a30146b24b25b242310ea">More...</a><br /></td></tr>
<tr class="separator:a07cb25d4557a30146b24b25b242310ea inherit pub_methods_classsf_1_1RenderTarget"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d1998464ccc54e789aaf990242b47f7 inherit pub_methods_classsf_1_1RenderTarget"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsf_1_1RenderTarget.html#a8d1998464ccc54e789aaf990242b47f7">pushGLStates</a> ()</td></tr>
<tr class="memdesc:a8d1998464ccc54e789aaf990242b47f7 inherit pub_methods_classsf_1_1RenderTarget"><td class="mdescLeft">&#160;</td><td class="mdescRight">Save the current OpenGL render states and matrices.  <a href="classsf_1_1RenderTarget.html#a8d1998464ccc54e789aaf990242b47f7">More...</a><br /></td></tr>
<tr class="separator:a8d1998464ccc54e789aaf990242b47f7 inherit pub_methods_classsf_1_1RenderTarget"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5a98401113df931ddcd54c080f7aa8e inherit pub_methods_classsf_1_1RenderTarget"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsf_1_1RenderTarget.html#ad5a98401113df931ddcd54c080f7aa8e">popGLStates</a> ()</td></tr>
<tr class="memdesc:ad5a98401113df931ddcd54c080f7aa8e inherit pub_methods_classsf_1_1RenderTarget"><td class="mdescLeft">&#160;</td><td class="mdescRight">Restore the previously saved OpenGL render states and matrices.  <a href="classsf_1_1RenderTarget.html#ad5a98401113df931ddcd54c080f7aa8e">More...</a><br /></td></tr>
<tr class="separator:ad5a98401113df931ddcd54c080f7aa8e inherit pub_methods_classsf_1_1RenderTarget"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac7504990d27dada4bfe3c7866920765 inherit pub_methods_classsf_1_1RenderTarget"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsf_1_1RenderTarget.html#aac7504990d27dada4bfe3c7866920765">resetGLStates</a> ()</td></tr>
<tr class="memdesc:aac7504990d27dada4bfe3c7866920765 inherit pub_methods_classsf_1_1RenderTarget"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset the internal OpenGL states so that the target is ready for drawing.  <a href="classsf_1_1RenderTarget.html#aac7504990d27dada4bfe3c7866920765">More...</a><br /></td></tr>
<tr class="separator:aac7504990d27dada4bfe3c7866920765 inherit pub_methods_classsf_1_1RenderTarget"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:aeb4454769233d10c915d130d3e009de9"><td class="memItemLeft" align="right" valign="top">static unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsf_1_1RenderTexture.html#aeb4454769233d10c915d130d3e009de9">getMaximumAntialiasingLevel</a> ()</td></tr>
<tr class="memdesc:aeb4454769233d10c915d130d3e009de9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the maximum anti-aliasing level supported by the system.  <a href="classsf_1_1RenderTexture.html#aeb4454769233d10c915d130d3e009de9">More...</a><br /></td></tr>
<tr class="separator:aeb4454769233d10c915d130d3e009de9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pro_methods_classsf_1_1RenderTarget"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classsf_1_1RenderTarget')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classsf_1_1RenderTarget.html">sf::RenderTarget</a></td></tr>
<tr class="memitem:a2997c96cbd93cb8ce0aba2ddae35b86f inherit pro_methods_classsf_1_1RenderTarget"><td class="memItemLeft" align="right" valign="top"><a id="a2997c96cbd93cb8ce0aba2ddae35b86f"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsf_1_1RenderTarget.html#a2997c96cbd93cb8ce0aba2ddae35b86f">RenderTarget</a> ()</td></tr>
<tr class="memdesc:a2997c96cbd93cb8ce0aba2ddae35b86f inherit pro_methods_classsf_1_1RenderTarget"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor. <br /></td></tr>
<tr class="separator:a2997c96cbd93cb8ce0aba2ddae35b86f inherit pro_methods_classsf_1_1RenderTarget"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af530274b34159d644e509b4b4dc43eb7 inherit pro_methods_classsf_1_1RenderTarget"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsf_1_1RenderTarget.html#af530274b34159d644e509b4b4dc43eb7">initialize</a> ()</td></tr>
<tr class="memdesc:af530274b34159d644e509b4b4dc43eb7 inherit pro_methods_classsf_1_1RenderTarget"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs the common initialization step after creation.  <a href="classsf_1_1RenderTarget.html#af530274b34159d644e509b4b4dc43eb7">More...</a><br /></td></tr>
<tr class="separator:af530274b34159d644e509b4b4dc43eb7 inherit pro_methods_classsf_1_1RenderTarget"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Target for off-screen 2D rendering into a texture. </p>
<p><a class="el" href="classsf_1_1RenderTexture.html" title="Target for off-screen 2D rendering into a texture.">sf::RenderTexture</a> is the little brother of <a class="el" href="classsf_1_1RenderWindow.html" title="Window that can serve as a target for 2D drawing.">sf::RenderWindow</a>. It implements the same 2D drawing and OpenGL-related functions (see their base class <a class="el" href="classsf_1_1RenderTarget.html" title="Base class for all render targets (window, texture, ...)">sf::RenderTarget</a> for more details), the difference is that the result is stored in an off-screen texture rather than being show in a window.</p>
<p>Rendering to a texture can be useful in a variety of situations: </p><ul>
<li>precomputing a complex static texture (like a level's background from multiple tiles) </li>
<li>applying post-effects to the whole scene with shaders </li>
<li>creating a sprite from a 3D object rendered with OpenGL </li>
<li>etc.</li>
</ul>
<p>Usage example:</p>
<div class="fragment"><div class="line"><span class="comment">// Create a new render-window</span></div>
<div class="line"><a class="code" href="classsf_1_1RenderWindow.html">sf::RenderWindow</a> window(<a class="code" href="classsf_1_1VideoMode.html">sf::VideoMode</a>(800, 600), <span class="stringliteral">&quot;SFML window&quot;</span>);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Create a new render-texture</span></div>
<div class="line"><a class="code" href="classsf_1_1RenderTexture.html">sf::RenderTexture</a> texture;</div>
<div class="line"><span class="keywordflow">if</span> (!texture.<a class="code" href="classsf_1_1RenderTexture.html#a0e945c4ce7703591c7f240b169744603">create</a>(500, 500))</div>
<div class="line">    <span class="keywordflow">return</span> -1;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// The main loop</span></div>
<div class="line"><span class="keywordflow">while</span> (window.isOpen())</div>
<div class="line">{</div>
<div class="line">   <span class="comment">// Event processing</span></div>
<div class="line">   <span class="comment">// ...</span></div>
<div class="line"> </div>
<div class="line">   <span class="comment">// Clear the whole texture with red color</span></div>
<div class="line">   texture.<a class="code" href="classsf_1_1RenderTarget.html#a6bb6f0ba348f2b1e2f46114aeaf60f26">clear</a>(<a class="code" href="classsf_1_1Color.html#a127dbf55db9c07d0fa8f4bfcbb97594a">sf::Color::Red</a>);</div>
<div class="line"> </div>
<div class="line">   <span class="comment">// Draw stuff to the texture</span></div>
<div class="line">   texture.<a class="code" href="classsf_1_1RenderTarget.html#a12417a3bcc245c41d957b29583556f39">draw</a>(sprite);  <span class="comment">// sprite is a sf::Sprite</span></div>
<div class="line">   texture.<a class="code" href="classsf_1_1RenderTarget.html#a12417a3bcc245c41d957b29583556f39">draw</a>(shape);   <span class="comment">// shape is a sf::Shape</span></div>
<div class="line">   texture.<a class="code" href="classsf_1_1RenderTarget.html#a12417a3bcc245c41d957b29583556f39">draw</a>(text);    <span class="comment">// text is a sf::Text</span></div>
<div class="line"> </div>
<div class="line">   <span class="comment">// We&#39;re done drawing to the texture</span></div>
<div class="line">   texture.<a class="code" href="classsf_1_1RenderTexture.html#af92886d5faef3916caff9fa9ab32c555">display</a>();</div>
<div class="line"> </div>
<div class="line">   <span class="comment">// Now we start rendering to the window, clear it first</span></div>
<div class="line">   window.clear();</div>
<div class="line"> </div>
<div class="line">   <span class="comment">// Draw the texture</span></div>
<div class="line">   <a class="code" href="classsf_1_1Sprite.html">sf::Sprite</a> sprite(texture.<a class="code" href="classsf_1_1RenderTexture.html#a61a6eba45d5c9e5c913aebeccb7b7eda">getTexture</a>());</div>
<div class="line">   window.draw(sprite);</div>
<div class="line"> </div>
<div class="line">   <span class="comment">// End the current frame and display its contents on screen</span></div>
<div class="line">   window.display();</div>
<div class="line">}</div>
<div class="ttc" id="aclasssf_1_1Color_html_a127dbf55db9c07d0fa8f4bfcbb97594a"><div class="ttname"><a href="classsf_1_1Color.html#a127dbf55db9c07d0fa8f4bfcbb97594a">sf::Color::Red</a></div><div class="ttdeci">static const Color Red</div><div class="ttdoc">Red predefined color.</div><div class="ttdef"><b>Definition:</b> Color.hpp:85</div></div>
<div class="ttc" id="aclasssf_1_1RenderTarget_html_a12417a3bcc245c41d957b29583556f39"><div class="ttname"><a href="classsf_1_1RenderTarget.html#a12417a3bcc245c41d957b29583556f39">sf::RenderTarget::draw</a></div><div class="ttdeci">void draw(const Drawable &amp;drawable, const RenderStates &amp;states=RenderStates::Default)</div><div class="ttdoc">Draw a drawable object to the render target.</div><div class="ttdef"><b>Definition:</b> RenderTarget.cpp:266</div></div>
<div class="ttc" id="aclasssf_1_1RenderTarget_html_a6bb6f0ba348f2b1e2f46114aeaf60f26"><div class="ttname"><a href="classsf_1_1RenderTarget.html#a6bb6f0ba348f2b1e2f46114aeaf60f26">sf::RenderTarget::clear</a></div><div class="ttdeci">void clear(const Color &amp;color=Color(0, 0, 0, 255))</div><div class="ttdoc">Clear the entire target with a single color.</div><div class="ttdef"><b>Definition:</b> RenderTarget.cpp:172</div></div>
<div class="ttc" id="aclasssf_1_1RenderTexture_html"><div class="ttname"><a href="classsf_1_1RenderTexture.html">sf::RenderTexture</a></div><div class="ttdoc">Target for off-screen 2D rendering into a texture.</div><div class="ttdef"><b>Definition:</b> RenderTexture.hpp:49</div></div>
<div class="ttc" id="aclasssf_1_1RenderTexture_html_a0e945c4ce7703591c7f240b169744603"><div class="ttname"><a href="classsf_1_1RenderTexture.html#a0e945c4ce7703591c7f240b169744603">sf::RenderTexture::create</a></div><div class="ttdeci">SFML_DEPRECATED bool create(unsigned int width, unsigned int height, bool depthBuffer)</div><div class="ttdoc">Create the render-texture.</div><div class="ttdef"><b>Definition:</b> RenderTexture.cpp:52</div></div>
<div class="ttc" id="aclasssf_1_1RenderTexture_html_a61a6eba45d5c9e5c913aebeccb7b7eda"><div class="ttname"><a href="classsf_1_1RenderTexture.html#a61a6eba45d5c9e5c913aebeccb7b7eda">sf::RenderTexture::getTexture</a></div><div class="ttdeci">const Texture &amp; getTexture() const</div><div class="ttdoc">Get a read-only reference to the target texture.</div><div class="ttdef"><b>Definition:</b> RenderTexture.cpp:191</div></div>
<div class="ttc" id="aclasssf_1_1RenderTexture_html_af92886d5faef3916caff9fa9ab32c555"><div class="ttname"><a href="classsf_1_1RenderTexture.html#af92886d5faef3916caff9fa9ab32c555">sf::RenderTexture::display</a></div><div class="ttdeci">void display()</div><div class="ttdoc">Update the contents of the target texture.</div><div class="ttdef"><b>Definition:</b> RenderTexture.cpp:164</div></div>
<div class="ttc" id="aclasssf_1_1RenderWindow_html"><div class="ttname"><a href="classsf_1_1RenderWindow.html">sf::RenderWindow</a></div><div class="ttdoc">Window that can serve as a target for 2D drawing.</div><div class="ttdef"><b>Definition:</b> RenderWindow.hpp:45</div></div>
<div class="ttc" id="aclasssf_1_1Sprite_html"><div class="ttname"><a href="classsf_1_1Sprite.html">sf::Sprite</a></div><div class="ttdoc">Drawable representation of a texture, with its own transformations, color, etc.</div><div class="ttdef"><b>Definition:</b> Sprite.hpp:48</div></div>
<div class="ttc" id="aclasssf_1_1VideoMode_html"><div class="ttname"><a href="classsf_1_1VideoMode.html">sf::VideoMode</a></div><div class="ttdoc">VideoMode defines a video mode (width, height, bpp)</div><div class="ttdef"><b>Definition:</b> VideoMode.hpp:42</div></div>
</div><!-- fragment --><p>Like <a class="el" href="classsf_1_1RenderWindow.html" title="Window that can serve as a target for 2D drawing.">sf::RenderWindow</a>, <a class="el" href="classsf_1_1RenderTexture.html" title="Target for off-screen 2D rendering into a texture.">sf::RenderTexture</a> is still able to render direct OpenGL stuff. It is even possible to mix together OpenGL calls and regular SFML drawing commands. If you need a depth buffer for 3D rendering, don't forget to request it when calling <a class="el" href="classsf_1_1RenderTexture.html#a0e945c4ce7703591c7f240b169744603" title="Create the render-texture.">RenderTexture::create</a>.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classsf_1_1RenderTarget.html" title="Base class for all render targets (window, texture, ...)">sf::RenderTarget</a>, <a class="el" href="classsf_1_1RenderWindow.html" title="Window that can serve as a target for 2D drawing.">sf::RenderWindow</a>, <a class="el" href="classsf_1_1View.html" title="2D camera that defines what region is shown on screen">sf::View</a>, <a class="el" href="classsf_1_1Texture.html" title="Image living on the graphics card that can be used for drawing.">sf::Texture</a> </dd></dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a19ee6e5b4c40ad251803389b3953a9c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19ee6e5b4c40ad251803389b3953a9c6">&#9670;&nbsp;</a></span>RenderTexture()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sf::RenderTexture::RenderTexture </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Default constructor. </p>
<p>Constructs an empty, invalid render-texture. You must call create to have a valid render-texture.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classsf_1_1RenderTexture.html#a0e945c4ce7703591c7f240b169744603" title="Create the render-texture.">create</a> </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a0e945c4ce7703591c7f240b169744603"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e945c4ce7703591c7f240b169744603">&#9670;&nbsp;</a></span>create() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool sf::RenderTexture::create </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>depthBuffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create the render-texture. </p>
<p>Before calling this function, the render-texture is in an invalid state, thus it is mandatory to call it before doing anything with the render-texture. The last parameter, <em>depthBuffer</em>, is useful if you want to use the render-texture for 3D OpenGL rendering that requires a depth buffer. Otherwise it is unnecessary, and you should leave this parameter to false (which is its default value).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">width</td><td>Width of the render-texture </td></tr>
    <tr><td class="paramname">height</td><td>Height of the render-texture </td></tr>
    <tr><td class="paramname">depthBuffer</td><td>Do you want this render-texture to have a depth buffer?</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if creation has been successful</dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000004">Deprecated:</a></b></dt><dd>Use <a class="el" href="classsf_1_1RenderTexture.html#a49b7b723a80f89bc409a942364351dc3" title="Create the render-texture.">create(unsigned int, unsigned int, const ContextSettings&amp;)</a> instead.</dd></dl>

</div>
</div>
<a id="a49b7b723a80f89bc409a942364351dc3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49b7b723a80f89bc409a942364351dc3">&#9670;&nbsp;</a></span>create() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool sf::RenderTexture::create </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structsf_1_1ContextSettings.html">ContextSettings</a> &amp;&#160;</td>
          <td class="paramname"><em>settings</em> = <code><a class="el" href="structsf_1_1ContextSettings.html">ContextSettings</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create the render-texture. </p>
<p>Before calling this function, the render-texture is in an invalid state, thus it is mandatory to call it before doing anything with the render-texture. The last parameter, <em>settings</em>, is useful if you want to enable multi-sampling or use the render-texture for OpenGL rendering that requires a depth or stencil buffer. Otherwise it is unnecessary, and you should leave this parameter at its default value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">width</td><td>Width of the render-texture </td></tr>
    <tr><td class="paramname">height</td><td>Height of the render-texture </td></tr>
    <tr><td class="paramname">settings</td><td>Additional settings for the underlying OpenGL texture and context</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if creation has been successful </dd></dl>

</div>
</div>
<a id="af92886d5faef3916caff9fa9ab32c555"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af92886d5faef3916caff9fa9ab32c555">&#9670;&nbsp;</a></span>display()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sf::RenderTexture::display </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Update the contents of the target texture. </p>
<p>This function updates the target texture with what has been drawn so far. Like for windows, calling this function is mandatory at the end of rendering. Not calling it may leave the texture in an undefined state. </p>

</div>
</div>
<a id="a8ca34c8b7e00793c1d3ef4f9a834f8cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ca34c8b7e00793c1d3ef4f9a834f8cc">&#9670;&nbsp;</a></span>generateMipmap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool sf::RenderTexture::generateMipmap </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate a mipmap using the current texture data. </p>
<p>This function is similar to <a class="el" href="classsf_1_1Texture.html#a7779a75c0324b5faff77602f871710a9" title="Generate a mipmap using the current texture data.">Texture::generateMipmap</a> and operates on the texture used as the target for drawing. Be aware that any draw operation may modify the base level image data. For this reason, calling this function only makes sense after all drawing is completed and display has been called. Not calling display after subsequent drawing will lead to undefined behavior if a mipmap had been previously generated.</p>
<dl class="section return"><dt>Returns</dt><dd>True if mipmap generation was successful, false if unsuccessful </dd></dl>

</div>
</div>
<a id="aeb4454769233d10c915d130d3e009de9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb4454769233d10c915d130d3e009de9">&#9670;&nbsp;</a></span>getMaximumAntialiasingLevel()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int sf::RenderTexture::getMaximumAntialiasingLevel </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the maximum anti-aliasing level supported by the system. </p>
<dl class="section return"><dt>Returns</dt><dd>The maximum anti-aliasing level supported by the system </dd></dl>

</div>
</div>
<a id="a09a4e928dafb7fcf397b8fd3d0f98ee8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09a4e928dafb7fcf397b8fd3d0f98ee8">&#9670;&nbsp;</a></span>getSize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsf_1_1Vector2.html">Vector2u</a> sf::RenderTexture::getSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the size of the rendering region of the texture. </p>
<p>The returned value is the size that you passed to the create function.</p>
<dl class="section return"><dt>Returns</dt><dd>Size in pixels </dd></dl>

<p>Implements <a class="el" href="classsf_1_1RenderTarget.html#a2e5ade2457d9fb4c4907ae5b3d9e94a5">sf::RenderTarget</a>.</p>

</div>
</div>
<a id="a61a6eba45d5c9e5c913aebeccb7b7eda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61a6eba45d5c9e5c913aebeccb7b7eda">&#9670;&nbsp;</a></span>getTexture()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classsf_1_1Texture.html">Texture</a> &amp; sf::RenderTexture::getTexture </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a read-only reference to the target texture. </p>
<p>After drawing to the render-texture and calling Display, you can retrieve the updated texture using this function, and draw it using a sprite (for example). The internal <a class="el" href="classsf_1_1Texture.html" title="Image living on the graphics card that can be used for drawing.">sf::Texture</a> of a render-texture is always the same instance, so that it is possible to call this function once and keep a reference to the texture even after it is modified.</p>
<dl class="section return"><dt>Returns</dt><dd>Const reference to the texture </dd></dl>

</div>
</div>
<a id="a81c5a453a21c7e78299b062b97dc8c87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81c5a453a21c7e78299b062b97dc8c87">&#9670;&nbsp;</a></span>isRepeated()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool sf::RenderTexture::isRepeated </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tell whether the texture is repeated or not. </p>
<dl class="section return"><dt>Returns</dt><dd>True if texture is repeated</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classsf_1_1RenderTexture.html#af8f97b33512bf7d5b6be3da6f65f7365" title="Enable or disable texture repeating.">setRepeated</a> </dd></dl>

</div>
</div>
<a id="a5b43c007ab6643accc5dae84b5bc8f61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b43c007ab6643accc5dae84b5bc8f61">&#9670;&nbsp;</a></span>isSmooth()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool sf::RenderTexture::isSmooth </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tell whether the smooth filtering is enabled or not. </p>
<dl class="section return"><dt>Returns</dt><dd>True if texture smoothing is enabled</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classsf_1_1RenderTexture.html#af08991e63c6020865dd07b20e27305b6" title="Enable or disable texture smoothing.">setSmooth</a> </dd></dl>

</div>
</div>
<a id="a2b0c1876cfb411d7db737d85b38c062c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b0c1876cfb411d7db737d85b38c062c">&#9670;&nbsp;</a></span>isSrgb()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool sf::RenderTexture::isSrgb </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tell if the render-texture will use sRGB encoding when drawing on it. </p>
<p>You can request sRGB encoding for a render-texture by having the sRgbCapable flag set for the context parameter of <a class="el" href="classsf_1_1RenderTexture.html#a0e945c4ce7703591c7f240b169744603" title="Create the render-texture.">create()</a> method</p>
<dl class="section return"><dt>Returns</dt><dd>True if the render-texture use sRGB encoding, false otherwise </dd></dl>

<p>Reimplemented from <a class="el" href="classsf_1_1RenderTarget.html#aa20edd15cd67e60b44a773c649105448">sf::RenderTarget</a>.</p>

</div>
</div>
<a id="a5da95ecdbce615a80bb78399012508cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5da95ecdbce615a80bb78399012508cf">&#9670;&nbsp;</a></span>setActive()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool sf::RenderTexture::setActive </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>active</em> = <code>true</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Activate or deactivate the render-texture for rendering. </p>
<p>This function makes the render-texture's context current for future OpenGL rendering operations (so you shouldn't care about it if you're not doing direct OpenGL stuff). Only one context can be current in a thread, so if you want to draw OpenGL geometry to another render target (like a <a class="el" href="classsf_1_1RenderWindow.html" title="Window that can serve as a target for 2D drawing.">RenderWindow</a>) don't forget to activate it again.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">active</td><td>True to activate, false to deactivate</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if operation was successful, false otherwise </dd></dl>

<p>Reimplemented from <a class="el" href="classsf_1_1RenderTarget.html#a86f66ad60dd65ede0d00bb3090c12484">sf::RenderTarget</a>.</p>

</div>
</div>
<a id="af8f97b33512bf7d5b6be3da6f65f7365"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8f97b33512bf7d5b6be3da6f65f7365">&#9670;&nbsp;</a></span>setRepeated()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sf::RenderTexture::setRepeated </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>repeated</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable or disable texture repeating. </p>
<p>This function is similar to <a class="el" href="classsf_1_1Texture.html#aaa87d1eff053b9d4d34a24c784a28658" title="Enable or disable repeating.">Texture::setRepeated</a>. This parameter is disabled by default.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">repeated</td><td>True to enable repeating, false to disable it</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classsf_1_1RenderTexture.html#a81c5a453a21c7e78299b062b97dc8c87" title="Tell whether the texture is repeated or not.">isRepeated</a> </dd></dl>

</div>
</div>
<a id="af08991e63c6020865dd07b20e27305b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af08991e63c6020865dd07b20e27305b6">&#9670;&nbsp;</a></span>setSmooth()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sf::RenderTexture::setSmooth </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>smooth</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable or disable texture smoothing. </p>
<p>This function is similar to <a class="el" href="classsf_1_1Texture.html#a0c3bd6825b9a99714f10d44179d74324" title="Enable or disable the smooth filter.">Texture::setSmooth</a>. This parameter is disabled by default.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">smooth</td><td>True to enable smoothing, false to disable it</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classsf_1_1RenderTexture.html#a5b43c007ab6643accc5dae84b5bc8f61" title="Tell whether the smooth filtering is enabled or not.">isSmooth</a> </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>libs/arm64/include/SFML/Graphics/<a class="el" href="RenderTexture_8hpp_source.html">RenderTexture.hpp</a></li>
<li>libs/unix/include/SFML/Graphics/RenderTexture.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
